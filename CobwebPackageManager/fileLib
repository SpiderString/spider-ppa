local repositoryListPath="macros/CobwebPackageManager/repositoryList" --path to repo list from .minecraft/advancedMacros
local packageListPath="macros/CobwebPackageManager/packageList" --path to package list from .minecraft/advancedMacros
local packageVersionsPath="macros/CobwebPackageManager/packageVersions"
local httpTimeout=15 --time in seconds before a request is cancelled
local httpColor="&5" --dark purple, color for http requests
local statusColor="&b" --aqua, color for status reports


run("CobwebPackageManager/spiderLib")

--writes a line to a file leaving all other lines untouched
function writeLine(line, lineNum, fileName)
  local file=catRel(fileName)
  table.insert(file, lineNum, line)
  local newFile=filesystem.open(fileName, "w")
  local index=1
  while file[index]~=nil do
    newFile.writeLine(file[index])
    index=index+1
  end
  newFile.close()
end
--takes a table of file lines and writes it
function writeFile(fileTable, fileName)
  local file=filesystem.open(fileName, "w")
  local index=1
  while fileTable[index]~=nil do
    file.writeLine(fileTable[index])
    index=index+1
  end
  file.close()
end
--gets a file from a url and puts it in a table
function getFile(url)
  local http=httpRequest({url=url}, {url=url, requestMethod="GET", timeout=httpTimeout})
  local file=http["input"]
  local err=http.getResponseCode()
  local line=file:readLine()
  local output={}
  while line~=nil do
    table.insert(output, line)
    line=file:readLine()
  end
  return output
end
--gets a single instruction from the make file and deletes it
function getInstruction(makeFile)
  local property={}
  local foundInstruction=false
  local line=1
  while makeFile[line]~=nil and not foundInstruction do
    --beginning of instruction
    if makeFile[line]:match("{") then
      line=line+1
      while not makeFile[line]:match("^%}$") do
        local entry=makeFile[line]:gsub("[%s]", "")
        local a, b = entry:find('%["[%a]+"%]')
        local field=entry:sub(a+1, b-1)
        field=field:gsub('"', "")
        local c=entry:find("=")
        local value=entry:sub(c+1)
        value=value:gsub('"', ""):gsub("[%s]+", "")
        property[field]=value
        line=line+1
      end
      foundInstruction=true
    else
      line=line+1
    end
  end
  --delete fetched instructions from file
  local currentLine=1
  while currentLine <= line do
    table.remove(makeFile, 1)
    currentLine=currentLine+1
  end
  return property
end

function doesBindingExist(profile, instruction)
  local foundMatch=false
  for id, binding in pairs(profile) do
    if not foundMatch then
      if binding["event"]==instruction["event"] and binding["script"]==instruction["script"] then
        foundMatch=true
      end
    end
  end
  return foundMatch
end
--takes an instruction from a make file and executes it
function setBinding(instruction)
  local profile=getProfile()
  local settings=getSettings()
  profile=settings["profiles"][profile]
  --if binding doesn't already exist
  if not doesBindingExist(profile, instruction) then
    instruction["enabled"]=true
    table.insert(profile, instruction)
  end
  settings.save()
end
--handles bindings and finishes installation
function make(makeFile)
  local line=makeFile[1]
  while line~=nil do
    local instruction=getInstruction(makeFile)
    if instruction~=nil then
      setBinding(instruction)
    end
    line=makeFile[1]
  end
end

--grabs package lists from repositories and writes to the package list
function getRepositories(silent)
  if silent=="true" or silent then silent=true
  else silent=false end
  local repoList=catRel(repositoryListPath)
  local repositories={}
  for id, line in pairs(repoList) do
    if line:match("^htt[ps]+://") then
      table.insert(repositories, line:match("[%S]+"))
    end
  end
  --fetch package lists from repositories
  local packages={}
  for id, url in pairs(repositories) do
    local packageList=httpRequest({url=url}, {url=url, requestMethod="GET", timeout=httpTimeout})["input"]
    if not silent then
      local a,b=url:find(".com")
      local c=url:find("/", b+2)
      local user=url:sub(b+2, c-1)
      local branch=url:sub(c+1, url:find("/", c+1)-1)
      advLog({text="GET:"..id.." ..."..user.."/"..branch.."...", color=httpColor, tooltip=url})
    end
    local line=packageList:readLine()
    while line~=nil do
      if line:match(":htt[ps]+://") then
        line=line:gsub("^[%s]*", "")
        table.insert(packages, line:match("[%S]+"))
      end
      line=packageList:readLine()
    end
  end
  --Get packages not already on the list
  if not filesystem.exists(packageListPath) then filesystem.open(packageListPath, "w"):close() end
  local packageList=catRel(packageListPath)
  local newPackages=0
  local newPackageList={}
  for id, package in pairs(packages) do
    if package:match(":htt[ps]+://") and not next(search(packageList, package)) then
      package=package:gsub("^[%s]*", "")
      table.insert(packageList, package:match("[%S]+"))
      table.insert(newPackageList, package:match("[%S]+"))
      newPackages=newPackages+1
    end
  end
  --write package list to packageList
  writeFile(packageList, packageListPath)
  if not silent then
    local newPackageString=""
    for id, package in pairs(newPackageList) do
      newPackageString=newPackageString..", "..package:sub(1, package:find(":")-1)
    end
    newPackageString=newPackageString:gsub("^, ", "")
    advLog({text="Package update complete. Added "..newPackages.." new packages.", color=statusColor, tooltip=newPackageString})
  end
  return newPackages
end
--searches for a package, returns nil if not found
function searchPackage(packageList, packageName)
  local packages={}
  for id, package in pairs(packageList) do
    local packageListName=package:sub(1, package:find(":")-1)
    if packageListName:lower()==packageName:lower() then
      table.insert(packages, package) 
    end
  end
  return packages
end
--searches the packageVersions file for the package and returns the version, nil if not found
function getPackageVersion(packageName)
  local packageVersion=nil
  local foundMatch=false
  if not filesystem.exists(packageVersionsPath) then filesystem.open(packageVersionsPath, "w"):close() end
  local versionsFile=catRel(packageVersionsPath)
  for id, line in pairs(versionsFile) do
    if line:sub(1, line:find(":")-1):lower()==packageName:lower() and not foundMatch then
      packageVersion=line:sub(line:find(":")+1):match("[%S]+")
      foundMatch=true
    end
  end
  return packageVersion
end
--updates version list for a given package
function writePackageVersion(packageName, version)
  local versionsFile=catRel(packageVersionsPath)
  local foundMatch=false
  for id, line in pairs(versionsFile) do
    if line:sub(1, line:find(":")-1):lower()==packageName:lower() and not foundMatch then
      packageVersion=line:sub(line:find(":")+1):match("[%S]+")
      versionsFile[id]=packageName..":"..version
      foundMatch=true
    end
  end
  if not foundMatch then
    table.insert(versionsFile, packageName..":"..version)
  end
  writeFile(versionsFile, packageVersionsPath)
end
--grabs scripts for a package
function getPackage(packageName, silent)
  if silent=="true" or silent then silent=true
  else silent=false end

  local packageList=catRel(packageListPath)
  local package=searchPackage(packageList, packageName)
  if next(package)==nil then
    advLog({text="Could not find package '"..packageName.."'", color=statusColor})
  else
    local packageId=package[1]:sub(1, package[1]:find(":")-1) --the package name in the repository
    local url=package[1]:match(":[%S]+"):gsub("^:", "")
    local scripts={}
    local scriptList=httpRequest({url=url}, {url=url, requestMethod="GET", timeout=httpTimeout})["input"]
    local line=scriptList:readLine()
    local packageVersion
    local AMVersion=_MOD_VERSION
    --gets script urls and names
    while line~=nil do
      if line:match(":http[ps]+://") then
        line=line:gsub("^[%s]*", "")
        local a=line:find(":")
        local scriptName=line:sub(1,a-1)
        local scriptUrl=line:sub(a+1)
        scripts[scriptName]=scriptUrl
      --get version
      elseif line:lower():match("^version:") then
        packageVersion=line:sub(line:find(":")+1):gsub("[%s]+", "")
      elseif line:lower():match("^am version:") then
        AMVersion=line:sub(line:find(":")+1):gsub("[%s]+", "")
        --change version here for simulating discrepancies
        --AMVersion="5.9.1"
      end
      line=scriptList:readLine()
    end

    --gets current installed version
    local installedVersion=getPackageVersion(packageId)
    if installedVersion==nil then
      installedVersion=-1
    end
    if packageVersion==nil then
      packageVersion=0
    end
    local upgrade=true
    --package version checking
    if tonumber(installedVersion)>=tonumber(packageVersion) and tonumber(installedVersion)~=0 then
      if not silent then
        advLog({text=packageId.." is already the newest version", color=statusColor})
      end
      upgrade=false
    --AM version checking
    else
      local major, minor, build
      local a, b, c
      AMVersion=tostring(AMVersion)
      a=AMVersion:find(".")+1
      c=AMVersion:sub(a+1)
      b=c:find(".")+1+a
      major=tonumber(AMVersion:sub(1, a-1))
      minor=tonumber(AMVersion:sub(a+1, b-1))
      build=tonumber(AMVersion:sub(b+1))

      local AMMajor, AMMinor, AMBuild
      a=_MOD_VERSION:find(".")+1
      c=_MOD_VERSION:sub(a+1)
      b=c:find(".")+1+a
      AMMajor=tonumber(_MOD_VERSION:sub(1, a-1))
      AMMinor=tonumber(_MOD_VERSION:sub(a+1, b-1))
      AMBuild=tonumber(_MOD_VERSION:sub(b+1))
      
      if AMMajor < major then
        upgrade=false
        
        local gu=(gui.new or gui.newGui)()
        local group=gu.newGroup()
        local guiOpen=true
        local guiWidth, guiHeight=gu.getSize()
        local yMargin=20
        
        local bg=gu.newRectangle(0, 0, guiWidth, guiHeight)
        bg.setParent(group)
        bg.setColor(0x70333333)

        gu.setOnClose(function() guiOpen=false end)
        local textArea={
          "&6Your Advanced Macros installation is version &c".._MOD_VERSION..".",
          "&6while the package '&b"..packageId.."&6' uses version &c"..AMVersion..".",
          "&6It is &chighly unlikely &6that this package will work with your version.",
          "",
          "",
          "&bInstall anyway?"
        }
        for id, text in pairs(textArea) do
          local t=gu.newText("&f"..text, 5, id*12+yMargin)
          t.setX((guiWidth-t.getWidth())/2)
          t.setParent(group)
        end
        
        local noBg=gu.newRectangle(2, (#textArea+1)*12+yMargin, 1, 1)
        noBg.setParent(group)
        noBg.setColor(0xe0333333)

        local yesBg=gu.newRectangle(2, (#textArea+2)*12+yMargin, 1, 1)
        yesBg.setParent(group)
        yesBg.setColor(0xe0333333)

        local noText=gu.newText("&aNo (Recommended)", 5, (#textArea+1)*12+yMargin)
        local yesText=gu.newText("&4Yes", 5, (#textArea+2)*12+yMargin)
        local width=math.max(noText.getWidth(), yesText.getWidth())
        noText.setX((guiWidth-noText.getWidth())/2)
        yesText.setX((guiWidth-yesText.getWidth())/2)

        noBg.setHeight(noText.getHeight())
        noBg.setWidth(width+6)
        noBg.setX((guiWidth-noBg.getWidth())/2)
        yesBg.setHeight(yesText.getHeight())
        yesBg.setWidth(width+6)
        yesBg.setX((guiWidth-yesBg.getWidth())/2)

        local noButton=gu.newBox(2, (#textArea+1)*12+yMargin, width+6, noText.getHeight())
        noButton.setOnMouseClick(function() gu.close() end)
        noButton.setX((guiWidth-noButton.getWidth())/2)       


        local yesButton=gu.newBox(2, (#textArea+2)*12+yMargin, width+6, yesText.getHeight())
        yesButton.setOnMouseClick(function() upgrade=true gu.close() end)
        yesButton.setX((guiWidth-yesButton.getWidth())/2)

        gu.open()
        while guiOpen do end

      elseif AMMinor < minor then
        upgrade=false

        local gu=(gui.new or gui.newGui)()
        local group=gu.newGroup()
        local guiOpen=true
        local guiWidth, guiHeight=gu.getSize()
        local yMargin=20
        
        local bg=gu.newRectangle(0, 0, guiWidth, guiHeight)
        bg.setParent(group)
        bg.setColor(0x70333333)

        gu.setOnClose(function() guiOpen=false end)
        local textArea={
          "&dYour Advanced Macros installation is version &c".._MOD_VERSION..".",
          "&dwhile the package '&b"..packageId.."&d' uses version &c"..AMVersion..".",
          "&dIt is &6possible&d that this package will not work with your version.",
          "",
          "",
          "&bInstall anyway?"
        }
        for id, text in pairs(textArea) do
          local t=gu.newText("&f"..text, 5, id*12+yMargin)
          t.setX((guiWidth-t.getWidth())/2)
          t.setParent(group)
        end
        
        local noBg=gu.newRectangle(2, (#textArea+1)*12+yMargin, 1, 1)
        noBg.setParent(group)
        noBg.setColor(0xe0333333)

        local yesBg=gu.newRectangle(2, (#textArea+2)*12+yMargin, 1, 1)
        yesBg.setParent(group)
        yesBg.setColor(0xe0333333)

        local noText=gu.newText("&aNo (Recommended)", 5, (#textArea+1)*12+yMargin)
        local yesText=gu.newText("&6Yes", 5, (#textArea+2)*12+yMargin)
        local width=math.max(noText.getWidth(), yesText.getWidth())
        noText.setX((guiWidth-noText.getWidth())/2)
        yesText.setX((guiWidth-yesText.getWidth())/2)

        noBg.setHeight(noText.getHeight())
        noBg.setWidth(width+6)
        noBg.setX((guiWidth-noBg.getWidth())/2)
        yesBg.setHeight(yesText.getHeight())
        yesBg.setWidth(width+6)
        yesBg.setX((guiWidth-yesBg.getWidth())/2)

        local noButton=gu.newBox(2, (#textArea+1)*12+yMargin, width+6, noText.getHeight())
        noButton.setOnMouseClick(function() gu.close() end)
        noButton.setX((guiWidth-noButton.getWidth())/2)       


        local yesButton=gu.newBox(2, (#textArea+2)*12+yMargin, width+6, yesText.getHeight())
        yesButton.setOnMouseClick(function() upgrade=true gu.close() end)
        yesButton.setX((guiWidth-yesButton.getWidth())/2)

        gu.open()
        while guiOpen do end

      end
    end
    if upgrade then
      --makes package directory
      if not filesystem.exists("macros/"..packageId) then 
        filesystem.mkDir("macros/"..packageId)
      end
      --downloads scripts
      for name, url in pairs(scripts) do
        if not silent then
          local fields=split(url, "/")
          local packageName=fields[fields["length"]-1]
          local scriptName=fields[fields["length"]]
          advLog({text="GET: ".."..."..packageName.."/"..scriptName.."...", color=httpColor, tooltip=url})
        end
        writeFile(getFile(url), "macros/"..packageId.."/"..name)
      end
      --get make instructions
      if filesystem.exists("macros/"..packageId.."/make") then
        local makeFile=catRel("macros/"..packageId.."/make")
        make(makeFile)
        filesystem.delete("macros/"..packageId.."/make")
      end
      --write new version
      writePackageVersion(packageId, packageVersion)
      if not silent then
        advLog({text="Installation Complete", color=statusColor, tooltip="Successfully installed "..packageId})
      end
      return packageId
    end
  end
end
function listPackages()
  --fetch repositories
  local repoList=catRel(repositoryListPath)
  for id, line in pairs(repoList) do
    if line:match("^htt[ps]+://") then
      local repo=line:match("[%S]+")
      --output repo
      local a,b=repo:find(".com")
      local c=repo:find("/", b+2)
      local user=repo:sub(b+2, c-1)
      local branch=repo:sub(c+1)
      advLog({text=user.."/"..branch, color=httpColor, tooltip=line})

      --check each repository for packages
      local packages={}
      local packageList=httpRequest({url=repo}, {url=repo, requestMethod="GET", timeout=httpTimeout})["input"]
      local line=packageList:readLine()
      while line~=nil do
        if line:match(":htt[ps]+://") then
          line=line:gsub("^[%s]*", "")
          advLog({text="      -"..line:sub(1, line:find(":")-1), color=statusColor, tooltip=line:sub(line:find(":")+1)})
          table.insert(packages, line:match("[%S]+"))
        end
        line=packageList:readLine()
      end
    end
  end
end
